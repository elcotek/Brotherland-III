using log4net;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Reflection;

namespace DOL.GS.Geometry
{
	/// <summary>
	/// Very basic Wavefront Obj file parser, parse only v, f and g (badly) entries
	/// with specific code to load obj file generated by Uthgard navgen tool
	/// </summary>
	public static class WavefrontObjFile
	{
		private static readonly ILog log = LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);

		public static (Vector3[], List<(int, int, int)[]>) Load(Zone zone, string filename)
		{
			if (File.Exists(filename + ".bin"))
				return LoadObjFromBinary(filename + ".bin");
			if (!File.Exists(filename))
				return (null, null);
			var offset = new Vector3(zone.XOffset, zone.YOffset, 0);
			var vertices = new List<Vector3>();
			var objects = new List<List<(int, int, int)>>();
			using (var reader = new StreamReader(filename))
			{
				string line;

				var faces = new List<(int, int, int)>();
				while ((line = reader.ReadLine()) != null)
				{
					if (string.IsNullOrWhiteSpace(line))
						continue;

					try
					{
						var args = line.Split(' ');
						switch (args[0])
						{
							// we ignore g entries, it's not very useful here
							case "v":
								// ATTENTION: the Y and Z are inverted so we load the model with DAOC coordinates (Z up instead of Y)
								var v = new Vector3(float.Parse(args[1], CultureInfo.InvariantCulture), float.Parse(args[3], CultureInfo.InvariantCulture), float.Parse(args[2], CultureInfo.InvariantCulture));
								v *= 32;
								vertices.Add(v);
								break;
							case "f":
								faces.Add((int.Parse(args[1]) - 1, int.Parse(args[2]) - 1, int.Parse(args[3]) - 1));
								break;
							case "g":
								if (vertices.Count > 0 && faces.Count > 0)
								{
									objects.Add(faces);
									faces = new List<(int, int, int)>();
								}
								break;
						}
					}
					catch (Exception e)
					{
						log.Debug($"Error when parsing obj file {filename}", e);
					}
				}
				if (vertices.Count > 0 && faces.Count > 0)
					objects.Add(faces);
			}

			var res = (vertices.ToArray(), objects.Select(faces => faces.ToArray()).ToList());
			SaveObjAsBinary(filename + ".bin", res);
			return res;
		}

		private static (Vector3[], List<(int, int, int)[]>) LoadObjFromBinary(string filename)
		{
			using (var br = new BinaryReader(File.OpenRead(filename)))
			{
				var vertices = new Vector3[br.ReadInt32()];
				for (var i = 0; i < vertices.Length; ++i)
				{
					var x = br.ReadSingle();
					var y = br.ReadSingle();
					var z = br.ReadSingle();
					vertices[i] = new Vector3(x, y, z);
				}

				var length = br.ReadInt32();
				var objects = new List<(int, int, int)[]>(length);
				for (var i = 0; i < length; ++i)
				{
					var nbFaces = br.ReadInt32();
					var faces = new (int, int, int)[nbFaces];
					for (var j = 0; j < nbFaces; ++j)
					{
						var a = br.ReadInt32();
						var b = br.ReadInt32();
						var c = br.ReadInt32();
						faces[j] = (a, b, c);
					}
					objects.Add(faces);
				}

				return (vertices, objects);
			}
		}
		private static void SaveObjAsBinary(string filename, (Vector3[], List<(int, int, int)[]>) obj)
		{
			using (var bw = new BinaryWriter(File.Create(filename)))
			{
				bw.Write(obj.Item1.Length);
				foreach (var v in obj.Item1)
				{
					bw.Write(v.X);
					bw.Write(v.Y);
					bw.Write(v.Z);
				}

				bw.Write(obj.Item2.Count);
				foreach (var o in obj.Item2)
				{
					bw.Write(o.Length);
					foreach (var (a, b, c) in o)
					{
						bw.Write(a);
						bw.Write(b);
						bw.Write(c);
					}
				}

				bw.Close();
			}
		}
	}
}
